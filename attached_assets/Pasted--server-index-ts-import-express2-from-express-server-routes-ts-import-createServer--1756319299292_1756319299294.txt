// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";
import multer from "multer";
import fs2 from "fs";

// server/storage.ts
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { eq, and, gte, lte, desc } from "drizzle-orm";

// shared/schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, integer, timestamp, uuid, time, date } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var users = pgTable("users", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  email: text("email").notNull().unique(),
  name: text("name").notNull(),
  role: text("role", { enum: ["student", "parent"] }).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`)
});
var courses = pgTable("courses", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  level: text("level").default("havo5")
});
var schedule = pgTable("schedule", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  courseId: uuid("course_id").references(() => courses.id),
  dayOfWeek: integer("day_of_week"),
  // 1=ma, 7=zo
  startTime: time("start_time"),
  endTime: time("end_time"),
  kind: text("kind", { enum: ["les", "toets"] }).default("les"),
  title: text("title"),
  date: date("date")
  // for one-off tests
});
var tasks = pgTable("tasks", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  courseId: uuid("course_id").references(() => courses.id),
  title: text("title").notNull(),
  dueAt: timestamp("due_at", { withTimezone: true }),
  estMinutes: integer("est_minutes"),
  priority: integer("priority").default(0),
  status: text("status").default("todo"),
  source: text("source"),
  // 'check-in' | 'manual'
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`)
});
var sessions = pgTable("sessions", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  happenedAt: timestamp("happened_at", { withTimezone: true }).default(sql`now()`),
  transcript: text("transcript"),
  summary: text("summary"),
  coachText: text("coach_text")
});
var materials = pgTable("materials", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  courseId: uuid("course_id").references(() => courses.id),
  title: text("title"),
  chapter: text("chapter"),
  paragraph: text("paragraph"),
  textContent: text("text_content"),
  // OCR result
  createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`)
});
var quizResults = pgTable("quiz_results", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: uuid("user_id").references(() => users.id).notNull(),
  courseId: uuid("course_id").references(() => courses.id),
  materialId: uuid("material_id").references(() => materials.id),
  score: integer("score"),
  weakPoints: text("weak_points")
});
var insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true
});
var insertCourseSchema = createInsertSchema(courses).omit({
  id: true
});
var insertScheduleSchema = createInsertSchema(schedule).omit({
  id: true
});
var insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true
});
var insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  happenedAt: true
});
var insertMaterialSchema = createInsertSchema(materials).omit({
  id: true,
  createdAt: true
});
var insertQuizResultSchema = createInsertSchema(quizResults).omit({
  id: true
});

// server/storage.ts
var databaseUrl = process.env.DATABASE_URL;
if (!databaseUrl) {
  throw new Error("DATABASE_URL environment variable is not set");
}
var connection = neon(databaseUrl);
var db = drizzle(connection);
var PostgresStorage = class {
  async getUser(id) {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }
  async getUserByEmail(email) {
    const result = await db.select().from(users).where(eq(users.email, email));
    return result[0];
  }
  async createUser(user) {
    const result = await db.insert(users).values(user).returning();
    return result[0];
  }
  async getCoursesByUserId(userId) {
    return await db.select().from(courses).where(eq(courses.userId, userId));
  }
  async createCourse(course) {
    const result = await db.insert(courses).values(course).returning();
    return result[0];
  }
  async getScheduleByUserId(userId) {
    return await db.select().from(schedule).where(eq(schedule.userId, userId));
  }
  async getScheduleByDay(userId, dayOfWeek) {
    return await db.select().from(schedule).where(and(
      eq(schedule.userId, userId),
      eq(schedule.dayOfWeek, dayOfWeek)
    ));
  }
  async createScheduleItem(scheduleItem) {
    const result = await db.insert(schedule).values(scheduleItem).returning();
    return result[0];
  }
  async deleteScheduleItem(id) {
    await db.delete(schedule).where(eq(schedule.id, id));
  }
  async getTasksByUserId(userId) {
    return await db.select().from(tasks).where(eq(tasks.userId, userId)).orderBy(desc(tasks.priority), tasks.dueAt);
  }
  async getTodayTasks(userId) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    return await db.select().from(tasks).where(and(
      eq(tasks.userId, userId),
      gte(tasks.dueAt, today),
      lte(tasks.dueAt, tomorrow)
    )).orderBy(desc(tasks.priority));
  }
  async getTasksByDateRange(userId, startDate, endDate) {
    return await db.select().from(tasks).where(and(
      eq(tasks.userId, userId),
      gte(tasks.dueAt, startDate),
      lte(tasks.dueAt, endDate)
    )).orderBy(desc(tasks.priority), tasks.dueAt);
  }
  async createTask(task) {
    const result = await db.insert(tasks).values(task).returning();
    return result[0];
  }
  async updateTaskStatus(id, status) {
    await db.update(tasks).set({ status }).where(eq(tasks.id, id));
  }
  async getLastSession(userId) {
    const result = await db.select().from(sessions).where(eq(sessions.userId, userId)).orderBy(desc(sessions.happenedAt)).limit(1);
    return result[0];
  }
  async getTodaySession(userId) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const result = await db.select().from(sessions).where(and(
      eq(sessions.userId, userId),
      gte(sessions.happenedAt, today),
      lte(sessions.happenedAt, tomorrow)
    )).limit(1);
    return result[0];
  }
  async createSession(session) {
    const result = await db.insert(sessions).values(session).returning();
    return result[0];
  }
  async createMaterial(material) {
    const result = await db.insert(materials).values(material).returning();
    return result[0];
  }
  async createQuizResult(result) {
    const queryResult = await db.insert(quizResults).values(result).returning();
    return queryResult[0];
  }
};
var storage = new PostgresStorage();

// server/services/openai.ts
import OpenAI from "openai";
import fs from "fs";
var openai = process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;
async function transcribeAudio(audioFilePath) {
  if (!openai) {
    return { text: "Vandaag moet ik wiskunde opgaven 5-10 maken en biologie presentatie voorbereiden." };
  }
  const audioReadStream = fs.createReadStream(audioFilePath);
  const transcription = await openai.audio.transcriptions.create({
    file: audioReadStream,
    model: "whisper-1"
  });
  return { text: transcription.text };
}
async function generatePlan(transcript, date2) {
  if (!openai) {
    return {
      tasks: [
        {
          title: "Wiskunde opgaven 5-10",
          course: "Wiskunde A",
          due_at: (/* @__PURE__ */ new Date()).toISOString(),
          est_minutes: 40,
          priority: 2
        }
      ],
      coach_text: "Vandaag pak je wiskunde opgaven 5-10. Neem je tijd en vraag hulp als je vastloopt."
    };
  }
  const response = await openai.chat.completions.create({
    model: "gpt-5",
    messages: [
      {
        role: "system",
        content: "Je bent een Nederlandse huiswerkcoach voor 5 havo. Beoordeel transcript, maak concrete taken (Titel, Vak, Deadline, Tijdinschatting), houd rekening met komende toetsen en rooster. Antwoord kort en actiegericht. Formatteer in JSON."
      },
      {
        role: "user",
        content: `Transcript: ${transcript}
Datum: ${date2}

Maak een planning met taken en coach advies in JSON formaat.`
      }
    ],
    response_format: { type: "json_object" }
  });
  return JSON.parse(response.choices[0].message.content || "{}");
}
async function generateExplanation(mode, text2, ocrText, course) {
  if (!openai) {
    return {
      steps: [
        "Identificeer de rechthoekige driehoek met de gegeven hoek",
        "Bepaal de overstaande zijde en de schuine zijde",
        "Gebruik de formule: sin(hoek) = overstaande zijde / schuine zijde"
      ],
      example: {
        prompt: "Gegeven: driehoek ABC met hoek A = 30\xB0, overstaande zijde = 5 cm, schuine zijde = 10 cm",
        solution: "sin(30\xB0) = 5/10 = 0.5"
      },
      quiz: {
        question: "Wat is sin(60\xB0) in een driehoek waar de overstaande zijde 8 cm is en de schuine zijde 10 cm?",
        choices: ["A) 0.6", "B) 0.8", "C) 1.25"],
        answer: "B"
      },
      coach_text: "Probeer eerst stap 1 en 2. Zeg 'help' als je vastloopt."
    };
  }
  const content = text2 || ocrText || "Algemene uitleg";
  const subject = course || "algemeen";
  const response = await openai.chat.completions.create({
    model: "gpt-5",
    messages: [
      {
        role: "system",
        content: "Je bent een Nederlandse huiswerkcoach voor 5 havo. Voor 'Ik snap dit niet': geef 3\u20136 genummerde uitlegstappen, 1 uitgewerkt voorbeeld, en 1 controlevraag met meerkeuze opties. Formatteer in JSON."
      },
      {
        role: "user",
        content: `Onderwerp: ${content}
Vak: ${subject}

Geef uitleg met stappen, voorbeeld en quiz in JSON formaat.`
      }
    ],
    response_format: { type: "json_object" }
  });
  return JSON.parse(response.choices[0].message.content || "{}");
}

// server/services/cron.ts
import cron from "node-cron";
var REMINDER_HOUR = parseInt(process.env.APP_REMINDER_HOUR || "16", 10);
function startDailyReminderCron() {
  cron.schedule(`0 ${REMINDER_HOUR} * * *`, async () => {
    console.log("Running daily reminder check...");
    await checkAndSendReminders();
  });
  console.log(`Daily reminder cron started for ${REMINDER_HOUR}:00`);
}
async function checkAndSendReminders() {
  let sent = 0;
  let skipped = 0;
  try {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    console.log("Daily reminder check completed");
    return { sent, skipped };
  } catch (error) {
    console.error("Error in daily reminder check:", error);
    return { sent: 0, skipped: 0 };
  }
}

// server/routes.ts
var upload = multer({ dest: "uploads/" });
async function registerRoutes(app2) {
  app2.get("/api/health", (req, res) => {
    res.json({ status: "OK", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  app2.post("/api/asr", upload.single("audio"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No audio file provided" });
      }
      const { text: text2 } = await transcribeAudio(req.file.path);
      fs2.unlinkSync(req.file.path);
      res.json({ transcript: text2 });
    } catch (error) {
      console.error("ASR error:", error);
      res.status(500).json({ error: "Failed to transcribe audio" });
    }
  });
  app2.post("/api/plan", async (req, res) => {
    try {
      const { transcript, date: date2, userId } = req.body;
      if (!transcript || !userId) {
        return res.status(400).json({ error: "Missing transcript or userId" });
      }
      const plan = await generatePlan(transcript, date2 || (/* @__PURE__ */ new Date()).toISOString());
      const createdTasks = [];
      for (const taskData of plan.tasks) {
        const courses2 = await storage.getCoursesByUserId(userId);
        const course = courses2.find((c) => c.name === taskData.course);
        const task = await storage.createTask({
          userId,
          courseId: course?.id || null,
          title: taskData.title,
          dueAt: new Date(taskData.due_at),
          estMinutes: taskData.est_minutes,
          priority: taskData.priority,
          source: "check-in",
          status: "todo"
        });
        createdTasks.push(task);
      }
      await storage.createSession({
        userId,
        transcript,
        summary: plan.coach_text,
        coachText: plan.coach_text
      });
      res.json({
        tasks: createdTasks,
        coach_text: plan.coach_text
      });
    } catch (error) {
      console.error("Planning error:", error);
      res.status(500).json({ error: "Failed to create plan" });
    }
  });
  app2.post("/api/tts", async (req, res) => {
    try {
      const { text: text2 } = req.body;
      if (!text2) {
        return res.status(400).json({ error: "No text provided" });
      }
      res.json({ audioUrl: "/api/tts/dummy.mp3" });
    } catch (error) {
      console.error("TTS error:", error);
      res.status(500).json({ error: "Failed to generate speech" });
    }
  });
  app2.post("/api/ocr", upload.single("image"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No image file provided" });
      }
      const dummyText = "Bereken de sinus van hoek A in een rechthoekige driehoek waar de overstaande zijde 6 cm is en de schuine zijde 10 cm.";
      fs2.unlinkSync(req.file.path);
      res.json({ text: dummyText });
    } catch (error) {
      console.error("OCR error:", error);
      res.status(500).json({ error: "Failed to process image" });
    }
  });
  app2.post("/api/explain", async (req, res) => {
    try {
      const { mode, text: text2, ocrText, course } = req.body;
      if (!mode || !text2 && !ocrText) {
        return res.status(400).json({ error: "Missing required parameters" });
      }
      const explanation = await generateExplanation(mode, text2, ocrText, course);
      res.json(explanation);
    } catch (error) {
      console.error("Explanation error:", error);
      res.status(500).json({ error: "Failed to generate explanation" });
    }
  });
  app2.get("/api/schedule/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const scheduleItems = await storage.getScheduleByUserId(userId);
      res.json(scheduleItems);
    } catch (error) {
      console.error("Schedule fetch error:", error);
      res.status(500).json({ error: "Failed to fetch schedule" });
    }
  });
  app2.post("/api/schedule", async (req, res) => {
    try {
      const scheduleData = insertScheduleSchema.parse(req.body);
      const created = await storage.createScheduleItem(scheduleData);
      res.json(created);
    } catch (error) {
      console.error("Schedule create error:", error);
      res.status(500).json({ error: "Failed to create schedule item" });
    }
  });
  app2.delete("/api/schedule/:id", async (req, res) => {
    try {
      const { id } = req.params;
      await storage.deleteScheduleItem(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Schedule delete error:", error);
      res.status(500).json({ error: "Failed to delete schedule item" });
    }
  });
  app2.get("/api/tasks/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const tasks2 = await storage.getTasksByUserId(userId);
      res.json(tasks2);
    } catch (error) {
      console.error("Tasks fetch error:", error);
      res.status(500).json({ error: "Failed to fetch tasks" });
    }
  });
  app2.get("/api/tasks/:userId/today", async (req, res) => {
    try {
      const { userId } = req.params;
      const tasks2 = await storage.getTodayTasks(userId);
      res.json(tasks2);
    } catch (error) {
      console.error("Today tasks fetch error:", error);
      res.status(500).json({ error: "Failed to fetch today's tasks" });
    }
  });
  app2.patch("/api/tasks/:id/status", async (req, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      await storage.updateTaskStatus(id, status);
      res.json({ success: true });
    } catch (error) {
      console.error("Task status update error:", error);
      res.status(500).json({ error: "Failed to update task status" });
    }
  });
  app2.post("/api/cron/daily-reminder", async (req, res) => {
    try {
      const result = await checkAndSendReminders();
      res.json(result);
    } catch (error) {
      console.error("Daily reminder error:", error);
      res.status(500).json({ error: "Failed to process daily reminders" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs3 from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    // Replit-only plugin in dev; wordt niet gebruikt op Vercel (NODE_ENV=production)
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID ? [(await import("@replit/vite-plugin-cartographer")).cartographer()] : []
  ],
  // Vite root is de 'client' map
  root: "client",
  resolve: {
    alias: {
      // Omdat root 'client' is, is 'src' al onder root.
      "@": path.resolve(process.cwd(), "client/src"),
      "@shared": path.resolve(process.cwd(), "shared"),
      "@assets": path.resolve(process.cwd(), "attached_assets")
    }
  },
  build: {
    // BELANGRIJK: relative outDir t.o.v. Vite root -> 'client/dist'
    outDir: "dist",
    assetsDir: "assets",
    emptyOutDir: true
  },
  base: "/",
  // correcte asset-paden in productie
  server: {
    fs: { strict: true, deny: ["**/.*"] }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs3.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs3.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "production") {
    startDailyReminderCron();
    log("Daily reminder cron job started");
  }
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();